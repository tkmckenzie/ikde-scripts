% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluate.posterior.R
\name{evaluate.posterior}
\alias{evaluate.posterior}
\title{Stan model posterior evaluation}
\usage{
evaluate.posterior(ikde.model, eval.point, burn.iter = 1000,
  sample.iter = 1000, control = NULL, refresh = NULL,
  display.output = FALSE, show.trace = FALSE)
}
\arguments{
\item{ikde.model}{An object of class ikde.model, does not necessarily have to be built}

\item{eval.point}{A list of parameter names and the point to evaluate the posterior}

\item{burn.iter}{Number of warmup iterations}

\item{sample.iter}{Number of sampling iterations}

\item{control}{Control parameters used in the Markov chain. See ?rstan::stan for details.}

\item{refresh}{How frequently should progress be reported, in numbers of iterations}

\item{display.output}{Boolean indicating whether output from rstan::stan should be printed}

\item{show.trace}{Boolean indicating whether to show trace plots}
}
\value{
A real number indicating value of the log-posterior at the specified evaluation point
}
\description{
Evaluates posterior of Stan model at specified evaluation point
}
\details{
Uses list of ikde.model objects created by create.restricted.models to estimate posterior
density. Each ikde.model is fit, then conditional posterior density is estimated at the
specified point.
}
\examples{
\donttest{
data(lm.generated)

X <- lm.generated$X
y <- lm.generated$y

data <- list(N = list("int<lower=1>", nrow(X)),
             k = list("int<lower=1>", ncol(X)),
             X = list("matrix[N, k]", X),
             y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
                   sigma_sq = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
                         "sigma_sq ~ inv_gamma(1, 1)"),
              likelihood = c("y ~ normal(X * beta, sqrt(sigma_sq))"))

ikde.model <- define.model(data, parameters, model)
ikde.model <- build.model(ikde.model)
stan.fit <- fit.model(ikde.model)
stan.extract <- rstan::extract(stan.fit)

eval.point <- list(beta = apply(stan.extract$beta, 2, mean),
                   sigma_sq = mean(stan.extract$sigma_sq))

# Only an estimation, may not exactly match presented result
evaluate.posterior(ikde.model, eval.point)
# [1] -1.889711
}

}
