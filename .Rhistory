source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
library(ikde)
example(build.model)
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sigma)"))
ikde.model <- define.model(data, parameters, model)
ikde.model <- build.model(ikde.model)
cat(ikde.model$stan.code)
ikde.model$stan.code
cat("asdf")
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sigma)"))
ikde.model <- define.model(data, parameters, model)
eval.point <- list(beta = c(1, 2, 3, 4),
sigma = 5)
ikde.model.list <- create.restricted.models(ikde.model, eval.point)
for (restricted.ikde.model in ikde.model.list){
cat(restricted.ikde.model$stan.code)
cat("--------------------------------------------------\n")
}
example(define.model)
?example
example("evaluate.expression")
data(lm.generated)
X <- lm.generated$X
X
example("evaluate.likelihood")
rm(list = ls())
example("evaluate.likelihood")
rm(list = ls())
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sigma)"))
ikde.model <- define.model(data, parameters, model)
eval.point <- list(beta = c(1, 2, 3, 4), sigma = 5)
# These results match:
evaluate.likelihood(ikde.model, eval.point)
sum(dnorm(y, X %*% eval.point$beta, eval.point$sigma, log = TRUE))
evaluate.statement(ikde.model$model$likelihood, ikde.model = ikde.model, eval.point = eval.point)
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
rm(list = ls())
library(ikde)
example("evaluate.likelihood")
example("evaluate.marginal.likelihood")
example("build.model")
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sigma)"))
ikde.model <- define.model(data, parameters, model)
ikde.model <- build.model(ikde.model)
stan.fit <- fit.model(ikde.model)
stan.extract <- rstan::extract(stan.fit)
eval.point <- list(beta = apply(stan.extract$beta, 2, mean),
sigma = mean(stan.extract$sigma))
evaluate.posterior(ikde.model, eval.point) # Only an estimation, may not exactly match presented result
library(ikde)
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sigma)"))
ikde.model <- define.model(data, parameters, model)
ikde.model <- build.model(ikde.model)
stan.fit <- fit.model(ikde.model)
stan.extract <- rstan::extract(stan.fit)
eval.point <- list(beta = apply(stan.extract$beta, 2, mean),
sigma = mean(stan.extract$sigma))
evaluate.posterior(ikde.model, eval.point) # Only an estimation, may not exactly match presented result
traceplot(stan.fit)
data(lm.generated)
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sigma)"))
ikde.model <- define.model(data, parameters, model)
ikde.model <- build.model(ikde.model)
stan.fit <- fit.model(ikde.model)
stan.extract <- rstan::extract(stan.fit)
eval.point <- list(beta = apply(stan.extract$beta, 2, mean),
sigma = mean(stan.extract$sigma))
evaluate.posterior(ikde.model, eval.point) # Only an estimation, may not exactly match presented result
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sigma)"))
ikde.model <- define.model(data, parameters, model)
ikde.model <- build.model(ikde.model)
stan.fit <- fit.model(ikde.model, 5000, 5000)
stan.extract <- rstan::extract(stan.fit)
eval.point <- list(beta = apply(stan.extract$beta, 2, mean),
sigma = mean(stan.extract$sigma))
evaluate.posterior(ikde.model, eval.point, 5000, 5000) # Only an estimation, may not exactly match presented result
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sigma)"))
ikde.model <- define.model(data, parameters, model)
ikde.model <- build.model(ikde.model)
stan.fit <- fit.model(ikde.model, 10000, 10000)
stan.extract <- rstan::extract(stan.fit)
eval.point <- list(beta = apply(stan.extract$beta, 2, mean),
sigma = mean(stan.extract$sigma))
evaluate.posterior(ikde.model, eval.point, 5000, 5000) # Only an estimation, may not exactly match presented result
example("evaluate.priors")
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
rm(list = ls())
library(ikde)
example("evaluate.priors")
example("evaluate.statement")
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sigma)"))
ikde.model <- define.model(data, parameters, model)
ikde.model <- build.model(ikde.model)
stan.fit <- fit.model(ikde.model)
stan.extract <- extract(stan.fit)
print(apply(stan.extract$beta, 2, mean)) # Only an estimation, may not exactly match presented result
example(`%stan*%`)
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
source('~/git/snfa-scripts/cran_downloads/cran_downloads_pull.R', echo=TRUE)
source('~/git/snfa-scripts/cran_downloads/cran_downloads_filter.R', echo=TRUE)
source('~/git/snfa-scripts/cran_downloads/cran_downloads_analysis.R', echo=TRUE)
temp.df
temp.df = df %>%
filter(date == "2018-12-13")
temp.df
det(diag(N))
det(diag(10))
det(0.1 * diag(10))
class(matrix(1:9, nrow = 3))
eigen(matrix(1:9, nrow = 3))
?mvrnorm
?rmvnorm
library(mvtnorm)
/mvtnorm::rmvnorm
?mvtnorm::rmvnorm
mvtnorm::rmvnorm(1)
mvtnorm::rmvnorm(1)
mvtnorm::rmvnorm(1, mean = rep(0, 3))
data(lm.generated)
X <- lm.generated$X
library(ikde)
data(lm.generated)
X <- lm.generated$X
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
library(ikde)
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
gibbs.fit <- gibbs.lm(X, y,
priors = list(beta.prior.mean = rep(0, 4),
beta.prior.var = 100 * diag(4),
sigma.prior.shape = 1,
sigma.prior.rate = 1))
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
library(ikde)
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
gibbs.fit <- gibbs.lm(X, y,
priors = list(beta.prior.mean = rep(0, 4),
beta.prior.var = 100 * diag(4),
sigma.prior.shape = 1,
sigma.prior.rate = 1))
plot(gibbs.fit$samples$beta, type = "l")
plot(gibbs.fit$samples$beta[,1], type = "l")
plot(gibbs.fit$samples$beta[,2], type = "l")
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
library(ikde)
examples(gibbs.lm)
example("gibbs.lm")
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
library(ikde)
example(gibbs.lm)
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
library(ikde)
example("gibbs.lm")
plot(gibbs.fit$samples$beta[1,], type = "l")
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
rm(list = ls())
library(ikde)
library(ikde)
example("gibbs.lm")
plot(gibbs.fit$samples$beta[1,], type = "l")
plot(gibbs.fit$samples$beta[,1], type = "l")
plot(gibbs.fit$samples$beta[,2], type = "l")
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
library(ikde)
example("evaluate.marginal.likelihood")
statement <- ikde.model$model$likelihood
statement
#Clean statement and extract left- and right-hand sides
statement <- gsub(" ", "", statement)
lhs <- strsplit(statement, "~")[[1]][1]
rhs <- strsplit(statement, "~")[[1]][2]
#Resolve variables in lhs
for (data.var in names(ikde.model$data)){
lhs <- gsub(data.var, paste0("ikde.model$data$", data.var, "[[2]]"), lhs)
}
for (eval.var in names(eval.point)){
lhs <- gsub(eval.var, paste0("eval.point$", eval.var), lhs)
}
#Extract distribution and map to R function
distribution.stan <- gsub("\\([0-9A-Za-z\\.,\\*/\\+-\\^_\\(\\)]+\\)$", "", rhs)
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
rm(list = ls())
library(ikde)
example("evaluate.marginal.likelihood")
example("gibbs.lm")
example("gibbs.lm")
example("gibbs.lm")
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
rm(list = ls())
library(ikde)
example("gibbs.lm")
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
rm(list = ls())
library(ikde)
example("gibbs.lm")
example("gibbs.lm")
example("gibbs.lm")
example("evaluate.marginal.likelihood")
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
library(ikde)
example("gibbs.lm")
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
rm(list = ls())
library(ikde)
example("gibbs.lm")
z = c("a", "b", "c")
!("a") %in% z
!("d") %in% z
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
library(ikde)
example("gibbs.lm")
priors = list(beta.prior.mean = rep(0, 4),
beta.prior.var = 100 * diag(4),
tau.prior.shape = 1,
tau.prior.rate = 1)
burn.iter = 1000
sample.iter = 1000
if (class(X) != "matrix") stop("X must be a matrix.")
if (class(y) != "numeric") stop("y must be a vector.")
if (class(priors) != "list") stop("priors must be a list.")
if (nrow(X) != length(y)) stop("X and y must have the same number of observations.")
N <- nrow(X)
k <- ncol(X)
if (!("beta.prior.mean" %in% names(priors))){
priors$beta.prior.mean <- rep(0, k)
} else{
if (length(priors$beta.prior.mean) != k) stop("beta.prior.mean has incorrect dimensions.")
}
if (!("beta.prior.var" %in% names(priors))){
priors$beta.prior.var <- diag(k)
} else{
if (any(dim(priors$beta.prior.var) != c(k, k))) stop("beta.prior.var has incorrect dimensions.")
if (any(priors$beta.prior.var != t(priors$beta.prior.var))) stop("beta.prior.var must be symmetric.")
if (any(eigen(priors$beta.prior.var)$values <= 0)) stop("beta.prior.var must be positive definite.")
}
if (!("tau.prior.shape" %in% names(priors))){
priors$tau.prior.shape <- 1
} else{
if (priors$tau.prior.shape <= 0) stop("tau.prior.shape must be positive.")
}
if (!("tau.prior.rate" %in% names(priors))){
priors$tau.prior.rate <- 1
} else{
if (priors$tau.prior.rate <= 0) stop("tau.prior.rate must be positive.")
}
# Initial values
beta <- rep(0, k)
tau <- 1
# Parameters for sampling
Sigma.beta.inv <- solve(priors$beta.prior.var)
Sigma.beta.inv.mu.beta <- Sigma.beta.inv %*% priors$beta.prior.mean
X.X <- t(X) %*% X
X.y <- t(X) %*% y
# Warmup
for (i in 1:burn.iter){
#beta
Sigma.beta.inv.post <- tau * X.X + Sigma.beta.inv
mu.beta.post <- solve(Sigma.beta.inv.post, (tau * X.y + Sigma.beta.inv.mu.beta))
beta <- mvtnorm::rmvnorm(1, mu.beta.post, solve(Sigma.beta.inv.post))[1,]
#tau
e <- y - X %*% beta
tau <- rgamma(1, priors$tau.prior.shape + N / 2, sum(e^2) / 2 + priors$tau.prior.rate)
}
# Sampling
beta.samples <- matrix(NA, nrow = sample.iter, ncol = k)
tau.samples <- rep(NA, sample.iter)
for (i in 1:sample.iter){
#beta
Sigma.beta.inv.post <- tau * X.X + Sigma.beta.inv
mu.beta.post <- solve(Sigma.beta.inv.post, (tau * X.y + Sigma.beta.inv.mu.beta))
beta <- mvtnorm::rmvnorm(1, mu.beta.post, solve(Sigma.beta.inv.post))[1,]
#tau
e <- y - X %*% beta
tau <- rgamma(1, priors$tau.prior.shape + N / 2, sum(e^2) / 2 + priors$tau.prior.rate)
#Store values
beta.samples[i,] <- beta
tau.samples[i] <- tau
}
# Marginal likelihood estimation
beta.star <- apply(beta.samples, 2, mean)
tau.star <- mean(tau.samples)
tau.posterior <- rep(NA, sample.iter)
#Start with density of tau|beta[s]
for (i in 1:sample.iter){
e <- y - X %*% beta.samples[i,]
tau.posterior[i] <- dgamma(tau.star, priors$tau.prior.shape + N / 2, sum(e^2) / 2 + priors$tau.prior.rate)
}
#Now do density of beta|tau*
Sigma.beta.inv.star <- tau.star * X.X + Sigma.beta.inv
mu.beta.star <- solve(Sigma.beta.inv.star, (tau.star * X.y + Sigma.beta.inv.mu.beta))
log.beta.posterior <- mvtnorm::dmvnorm(beta.star, mu.beta.star, solve(Sigma.beta.inv.star), log = TRUE)
#Wrap everything together
log.posterior <- log(mean(tau.posterior)) + log.beta.posterior
log.prior <- mvtnorm::dmvnorm(beta.star, priors$beta.prior.mean, priors$beta.prior.var, log = TRUE) +
dgamma(tau.star, priors$tau.prior.shape, priors$tau.prior.rate, log = TRUE)
log.lik <- sum(dnorm(y, X %*% beta.star, 1 / sqrt(tau.star), log = TRUE))
log.marginal <- log.lik + log.prior - log.posterior
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma_sq = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma_sq ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sqrt(sigma_sq))"))
ikde.model <- define.model(data, parameters, model)
if (class(ikde.model) != "ikde.model") stop("ikde.model must be of class \"ikde.model\".")
if (!ikde.model$built) ikde.model <- build.model(ikde.model)
stan.fit <- fit.model(ikde.model, burn.iter, sample.iter, 1, control, refresh, display.output)
refresh = NULL
control = NULL
display.output = FALSE
show.trace = FALSE
stan.fit <- fit.model(ikde.model, burn.iter, sample.iter, 1, control, refresh, display.output)
stan.extract <- rstan::extract(stan.fit)
num.paramters <- length(stan.extract) - 1
eval.point <- list()
for (parameter.name in names(stan.extract)[-(num.paramters + 1)]){
if (length(dim(stan.extract[[parameter.name]])) == 1){
eval.point[[parameter.name]] <- mean(stan.extract[[parameter.name]])
} else if (length(dim(stan.extract[[parameter.name]])) == 2){
eval.point[[parameter.name]] <- apply(stan.extract[[parameter.name]], 2, mean)
} else{
stop("ikde currently only supports 0- and 1-dimensional parameters.")
}
}
eval.point
log.lik <- evaluate.likelihood(ikde.model, eval.point)
log.prior <- evaluate.priors(ikde.model, eval.point)
log.posterior <- evaluate.posterior(ikde.model, eval.point, burn.iter, sample.iter, control, refresh, display.output, show.trace)
data(lm.generated)
X <- lm.generated$X
y <- lm.generated$y
data <- list(N = list("int<lower=1>", nrow(X)),
k = list("int<lower=1>", ncol(X)),
X = list("matrix[N, k]", X),
y = list("vector[N]", y))
parameters <- list(beta = "vector[k]",
sigma_sq = "real<lower=0>")
model <- list(priors = c("beta ~ normal(0, 10)",
"sigma_sq ~ inv_gamma(1, 1)"),
likelihood = c("y ~ normal(X * beta, sqrt(sigma_sq))"))
ikde.model <- define.model(data, parameters, model)
evaluate.marginal.likelihood(ikde.model, 5000, 5000) # Only an estimation, may not exactly match presented result
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
rm(list = ls())
source('~/git/ikde-scripts/ikde_test.R', echo=TRUE)
library(mvtnorm)
dmvnorm(eval.point$beta, rep(0, 4), 100 * diag(4), log = TRUE)
evaluate.statement(ikde.model$model$proi)
evaluate.statement(ikde.model$model$priors[1], ikde.model = ikde.model, eval.point = eval.point)
evaluate.statement(ikde.model$model$priors[2], ikde.model = ikde.model, eval.point = eval.point)
ikde.model$model$priors[2]
eval.point
ikde.model$stan.code
ikde.model$model$priors
dgamma(1 / eval.point$sigma_sq, priors$tau.prior.shape, priors$tau.prior.rate, log = TRUE)
dgamma(1 / eval.point$sigma_sq, 1, 1, log = TRUE)
invgamma::dinvgamma(eval.point$sigma_sq, 1, 1, log = TRUE)
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
source('~/git/ikde-scripts/ikde_test.R', echo=TRUE)
eval.point$sigma_sq
source('~/git/ikde-scripts/ikde_test.R', echo=TRUE)
eval.point
source('~/git/ikde-scripts/1_document.R', echo=TRUE)
source('~/git/ikde-scripts/2_reinstall.R', echo=TRUE)
source('~/git/ikde-scripts/ikde_test.R', echo=TRUE)
#Compare log-marginals
#These don't match
evaluate.marginal.likelihood(ikde.model, 5000, 5000) # [1] -365.8268
